<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assignment 3</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }

        h1,
        h2 {
            color: #4CAF50;
        }

        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow-x: auto;
        }

        a {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            color: white;
            background-color: #4CAF50;
            text-decoration: none;
            border-radius: 5px;
        }

        a:hover {
            background-color: #45a049;
        }
    </style>
</head>

<body>
    <h1>Assignment 3</h1>
    <h2>Code:</h2>
    <pre>
        import java.util.Arrays;

public class FloydWarshall {

    // Define a large value for infinity
    final static int INF = 99999;

    // Floyd-Warshall algorithm implementation
    public static void floydWarshall(int[][] graph) {
        int n = graph.length; // Number of cities
        int[][] dist = new int[n][n];

        // Initialize the solution matrix same as input graph matrix
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = graph[i][j];
            }
        }

        // Update the solution matrix with the shortest paths
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != INF && dist[k][j] != INF) {
                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }

        // Print the shortest path matrix
        printSolution(dist);
    }

    // Print the solution matrix
    public static void printSolution(int[][] dist) {
        int n = dist.length;
        System.out.println("Shortest distances between every pair of cities:");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][j] == INF) {
                    System.out.print("INF ");
                } else {
                    System.out.print(dist[i][j] + "   ");
                }
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        // Input graph: adjacency matrix representation
        // 0 represents no self-loop; INF represents no direct connection
        int[][] graph = {
            {0, 3, INF, INF, INF, INF},
            {3, 0, 1, INF, INF, INF},
            {INF, 1, 0, 7, INF, 2},
            {INF, INF, 7, 0, 2, 3},
            {INF, INF, INF, 2, 0, 4},
            {INF, INF, 2, 3, 4, 0}
        };

        // Run Floyd-Warshall algorithm
        floydWarshall(graph);
    }
}

        
    </pre>
    <h2>Explanation:</h2>
    <p>Explanation of the Code
        Input:

        The adjacency matrix represents the graph. Each entry
        ğ‘”
        ğ‘Ÿ
        ğ‘
        ğ‘
        â„
        [
        ğ‘–
        ]
        [
        ğ‘—
        ]
        graph[i][j] is the cost of connecting city
        ğ‘–
        i to city
        ğ‘—
        j. If there's no direct connection, it's set to INF.
        Initialization:

        The dist matrix is initialized as a copy of the graph matrix.
        Triple Nested Loops:

        The outer loop iterates through intermediate nodes
        ğ‘˜
        k.
        The middle and inner loops iterate through all pairs of nodes
        ğ‘–
        i and
        ğ‘—
        j to update the minimum distance using the intermediate node
        ğ‘˜
        k.
        Output:

        The dist matrix contains the shortest distances between all pairs of cities after the algorithm completes.
        Time Complexity
        The Floyd-Warshall algorithm has a time complexity of
        ğ‘‚
        (
        ğ‘›
        3
        )
        O(n
        3
        ), where
        ğ‘›
        n is the number of cities.
        Space Complexity
        The space complexity is
        ğ‘‚
        (
        ğ‘›
        2
        )
        O(n
        2
        ) due to the distance matrix.
    </p>
    <a href="index.html">Back to Home</a>
</body>

</html>